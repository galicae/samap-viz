[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "samap-viz",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "samap-viz",
    "section": "Install",
    "text": "Install\npip install samap_viz"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "samap-viz",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2"
  },
  {
    "objectID": "util.html",
    "href": "util.html",
    "title": "util",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\n\nimport scanpy as sc\nimport anndata as ad\n\n\nsource\n\nprocrustes\n\n procrustes (x:str, appropriate_length:int=50, pad_with:str=' ',\n             side:str='right')\n\nA function to regulate string length.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx\nstr\n\ninput string\n\n\nappropriate_length\nint\n50\ndesired length\n\n\npad_with\nstr\n\ncharacter to pad with\n\n\nside\nstr\nright\nwhich side to pad on (“left”, “right”)\n\n\nReturns\nstr\n\nstring with desired length\n\n\n\nWe are primarily going to be working with non-model species, so the gene names will always be of the form\nXLOC_123456 | emapper-name-or-description-if-we're-lucky\nor something similar. This means that we could have extreme variation in the actual length of a gene “name”; this will make it very hard to put gene names on axes as it will distort figure sizes. I wrote a function to either trim or pad strings; even though axis labels are not in monospace fonts, it is much easier to visually reconcile strings with lengths in the same order of magnitude.\n\ntoo_short = 'Niko'\njust_right = 'Theseus'\ntoo_tall = 'The Mountain'\n\n\nassert procrustes(just_right, appropriate_length=7) == 'Theseus'\nassert procrustes(too_short, appropriate_length=7) == 'Niko   '\nassert procrustes(too_tall, appropriate_length=7) == 'The Mou'\n\n\n\nsource\n\n\ngrouped_obs_mean\n\n grouped_obs_mean (adata:anndata._core.anndata.AnnData, group_key:str,\n                   layer:str=None)\n\nHelper function to calculate average expression per group in an AnnData object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nAnnData object to analyse\n\n\ngroup_key\nstr\n\n.obs category to group by\n\n\nlayer\nstr\nNone\nlayer to use. If none, use .X\n\n\nReturns\nDataFrame\n\na groups\\(\\times\\)genes dataframe with the average expression\n\n\n\nMany tasks in single-cell analysis require us to know the average expression of a gene in a certain group of cells. While scanpy does perform that task behind the scenes for, e.g. dotplots, this is not functionality that is exposed to the users. This is an implementation based on ivirshup’s answer to a scanpy issue.\n\nadata = sc.read_h5ad('../example_data/hydra.h5ad')\n\ncluster_means = grouped_obs_mean(adata, group_key='Cluster')\n\nIf \\(G\\) is the number of genes and \\(C\\) the number of unique clusters in the group_key, the returned array should have the shape \\(G \\times C\\):\n\nno_genes = adata.shape[1]\nno_clusters = len(np.unique(adata.obs['Cluster']))\nassert cluster_means.shape == (no_genes, no_clusters)\n\nAdditionally, each column of the array should contain the average detected expression for cells in that cluster:\n\nbelong_to_ecEp_SC2 = adata.obs['Cluster'] == 'ecEp_SC2'\necEp_SC2_average = np.mean(adata[belong_to_ecEp_SC2].X, axis=0)\necEp_SC2_average = np.array(ecEp_SC2_average)[0]\n\nassert all(np.isclose(cluster_means['ecEp_SC2'], ecEp_SC2_average))\n\n\nsource\n\n\ngrouped_obs_present\n\n grouped_obs_present (adata:anndata._core.anndata.AnnData, group_key:str,\n                      layer:str=None)\n\nHelper function to calculate how many cells express each gene per group in an AnnData object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nAnnData object to analyse\n\n\ngroup_key\nstr\n\n.obs category to group by\n\n\nlayer\nstr\nNone\nlayer to use. If none, use .X\n\n\nReturns\nDataFrame\n\na groups\\(\\times\\)genes dataframe with the number of expressing cells\n\n\n\nAnother critical value to know when making dotplots is the fraction of cells expressing a gene in a certain cluster. Again, scanpy performs that task without exposing it to the users. Similar to [grouped_obs_mean](https://galicae.github.io/samap-viz/util.html#grouped_obs_mean) this is an implementation based on ivirshup’s answer to a scanpy issue. Here we calculate the sum of cells expressing a gene, a table we can use to calculate the fraction later.\n\nnum_expressing = grouped_obs_present(adata, group_key='Cluster')\n\nIf \\(G\\) is the number of genes and \\(C\\) the number of unique clusters in the group_key, the returned array should have the shape \\(G \\times C\\):\n\nassert num_expressing.shape == (no_genes, no_clusters)\n\nAdditionally, each column of the array should contain the percentage of cells expressing each gene in that cluster:\n\nbelong_to_ecEp_SC2 = adata.obs['Cluster'] == 'ecEp_SC2'\necEp_SC2_expr = np.sum(adata[belong_to_ecEp_SC2].X>0, axis=0)\necEp_SC2_expr = np.array(ecEp_SC2_expr)[0]\n\nassert all(num_expressing['ecEp_SC2'] == ecEp_SC2_expr)\n\n\nsource\n\n\ngrouped_obs_percent\n\n grouped_obs_percent (adata:anndata._core.anndata.AnnData, group_key:str,\n                      layer:str=None)\n\nHelper function to calculate how many cells express each gene per group in an AnnData object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nadata\nAnnData\n\nAnnData object to analyse\n\n\ngroup_key\nstr\n\n.obs category to group by\n\n\nlayer\nstr\nNone\nlayer to use. If none, use .X\n\n\nReturns\nDataFrame\n\na groups\\(\\times\\)genes dataframe with the number of expressing cells\n\n\n\nCalculating the fraction of cells is of course very straightforward once we have counted the number of cells that express the gene as well as the total number of cells in a cluster.\n\nfrac_expressing = grouped_obs_percent(adata, group_key='Cluster')\n# use the counts and number of cells we calculated before\nfrac_ecEp_SC2 = ecEp_SC2_expr / np.sum(belong_to_ecEp_SC2)\n\nassert all(np.isclose(frac_expressing['ecEp_SC2'], frac_ecEp_SC2))"
  }
]